detect.cloiso <- function(laz_norm, resolution = 1, threshold = 0.1, min_area = 10, output_file = "cloisonnements_norm.gpkg") {
  
  if (is.null(laz_norm) || npoints(laz_norm) == 0) {
    stop("Le fichier LAZ est vide ou n'a pas été chargé correctement.")
  }
  
  # 1. Calculer la densité des points
  density <- grid_density(laz_norm, res = resolution)
  
  # 2. Calculer le nombre de retours
  returns <- grid_metrics(laz_norm, ~length(Z), res = resolution)
  names(returns) <- "num_returns"
  
  # 3. MNH (Modèle Numérique de Hauteur)
  mnh <- grid_canopy(laz_norm, res = resolution, algorithm = pitfree())
  names(mnh) <- "mnh_height"
  
  # 4. Empiler les rasters pour les combiner
  combined_stack <- raster::stack(density, returns, mnh)
  
  # Convertir en data frame pour traitement
  combined_df <- as.data.frame(combined_stack, xy = TRUE)
  
  # Vérifier la présence de valeurs NA et appliquer na.rm = TRUE
  combined_df <- na.omit(combined_df)  # Suppression des lignes avec des NA
  
  # 5. Détecter les zones à faible densité, faible nombre de retours et faible hauteur
  combined_df$low_density <- ifelse(combined_df$density < quantile(combined_df$density, threshold, na.rm = TRUE), 1, 0)
  combined_df$low_returns <- ifelse(combined_df$num_returns < quantile(combined_df$num_returns, threshold, na.rm = TRUE), 1, 0)
  combined_df$low_mnh <- ifelse(combined_df$mnh_height < quantile(combined_df$mnh_height, threshold, na.rm = TRUE), 1, 0)
  
  # 6. Détecter les cloisonnements
  combined_df$cloisonnement <- ifelse(combined_df$low_density == 1 & combined_df$low_returns == 1 & combined_df$low_mnh == 1, 1, 0)
  
  # 7. Filtrer les zones de cloisonnements
  cloisonnements_points <- combined_df[combined_df$cloisonnement == 1, ]
  
  # 8. Convertir en objet spatial
  if (nrow(cloisonnements_points) > 0) {
    cloisonnements_sf <- st_as_sf(cloisonnements_points, coords = c("x", "y"), crs = st_crs(laz_norm))
    
    # 9. Appliquer un buffer et dissoudre pour connecter les points proches (générer des polygones)
    cloisonnements_buffer <- st_buffer(cloisonnements_sf, dist = resolution * 1.5)
    cloisonnements_dissolved <- st_union(cloisonnements_buffer)
    
    # 10. Filtrer les polygones de petite surface
    cloisonnements_filtered <- cloisonnements_dissolved[st_area(cloisonnements_dissolved) > units::set_units(min_area, "m^2")]
    
    # Assurez-vous que l'objet est bien un sf
    cloisonnements_filtered <- st_as_sf(cloisonnements_filtered)
    
    # 11. Exporter au format GPKG
    st_write(cloisonnements_filtered, output_file, driver = "GPKG", delete_layer = TRUE)
    message("Cloisonnements exportés vers ", output_file)
    
    return(cloisonnements_filtered)
  } else {
    message("Aucun cloisonnement détecté.")
    return(NULL)
  }
}
