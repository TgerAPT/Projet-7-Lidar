detect.cloiso <- function(laz_norm, resolution = 0.5, line_length = 20, gap_fill = 5, slope_threshold = 5, output_file = "cloisonnements_norm.gpkg") {
  
  if (is.null(laz_norm) || npoints(laz_norm) == 0) {
    stop("Le fichier LAZ est vide ou n'a pas été chargé correctement.")
  }
  
  # Nettoyage des points dégénérés
  laz_norm <- filter_duplicates(laz_norm)
  
  # 1. Créer un MNT à haute résolution
  mnt <- grid_terrain(laz_norm, res = resolution, algorithm = tin())
  print(paste("Dimensions du MNT:", paste(dim(mnt), collapse = "x")))
  
  # 2. Calculer la pente
  slope <- terra::terrain(mnt, v = "slope", unit = "degrees")
  print(paste("Dimensions de la pente:", paste(dim(slope), collapse = "x")))
  
  # 3. Identifier les zones planes (potentiels cloisonnements)
  flat_areas <- slope < slope_threshold
  print(paste("Dimensions des zones planes:", paste(dim(flat_areas), collapse = "x")))
  
  # 4. Convertir en matrice pour le traitement
  img_matrix <- as.matrix(flat_areas)
  print(paste("Dimensions de la matrice d'image:", paste(dim(img_matrix), collapse = "x")))
  
  # 5. Détection de contours simple
  if (nrow(img_matrix) > 1 && ncol(img_matrix) > 1) {
    edges <- edge_detection(img_matrix)
    print(paste("Dimensions des contours:", paste(dim(edges), collapse = "x")))
    
    # 6. Binarisation des contours
    edges_bin <- edges > quantile(edges, 0.9, na.rm = TRUE)
    
    # 7. Extraction des coordonnées des pixels de contour
    edge_coords <- which(edges_bin > 0, arr.ind = TRUE)
    print(paste("Nombre de points de contour:", nrow(edge_coords)))
    
    # 8. Création des lignes à partir des coordonnées des contours
    if (nrow(edge_coords) > 1) {
      lines_sf <- tryCatch({
        create_lines_from_coords(edge_coords, resolution, st_crs(laz_norm))
      }, error = function(e) {
        message("Erreur lors de la création des lignes : ", e$message)
        return(NULL)
      })
      
      if (is.null(lines_sf) || length(lines_sf) == 0) {
        message("Aucune ligne n'a été créée. Vérifiez les paramètres ou les données d'entrée.")
        return(NULL)
      }
      
      # 9. Filtrer les lignes trop courtes
      lines_length <- st_length(lines_sf)
      lines_sf <- lines_sf[as.numeric(lines_length) > line_length]
      
      if (length(lines_sf) == 0) {
        message("Aucune ligne ne dépasse la longueur minimale. Ajustez le paramètre line_length ou vérifiez les données d'entrée.")
        return(NULL)
      }
      
      # 10. Fusionner les lignes proches
      lines_buffered <- st_buffer(lines_sf, dist = gap_fill)
      lines_merged <- st_cast(st_union(lines_buffered), "LINESTRING")
      
      # 11. Nettoyer et simplifier les lignes finales
      lines_final <- st_simplify(lines_merged, dTolerance = resolution)
      
      # 12. Exporter au format GPKG
      st_write(lines_final, output_file, driver = "GPKG", delete_layer = TRUE)
      message("Cloisonnements exportés vers ", output_file)
      
      return(lines_final)
    } else {
      message("Pas assez de points de contour détectés. Vérifiez les paramètres ou les données d'entrée.")
      return(NULL)
    }
  } else {
    message("L'image est trop petite pour détecter des contours.")
    return(NULL)
  }
}

# Fonction auxiliaire pour la détection des contours
edge_detection <- function(img_matrix) {
  dx <- diff(img_matrix, differences = 1, lag = 1, dim = 2)
  dy <- diff(img_matrix, differences = 1, lag = 1, dim = 1)
  
  # Assurez-vous que dx et dy ont la même taille
  min_rows <- min(nrow(dx), nrow(dy))
  min_cols <- min(ncol(dx), ncol(dy))
  
  dx <- dx[1:min_rows, 1:min_cols]
  dy <- dy[1:min_rows, 1:min_cols]
  
  edges <- sqrt(dx^2 + dy^2)
  return(edges)
}

# Fonction auxiliaire pour créer des lignes à partir des coordonnées
create_lines_from_coords <- function(edge_coords, resolution, crs) {
  # Trier les coordonnées pour une meilleure connexion des points
  edge_coords <- edge_coords[order(edge_coords[,1], edge_coords[,2]),]
  
  # Créer des groupes de points proches
  dist <- sqrt(diff(edge_coords[,1])^2 + diff(edge_coords[,2])^2)
  groups <- cumsum(c(1, dist > 1))
  
  # Créer des lignes pour chaque groupe
  lines_list <- lapply(split(edge_coords, groups), function(group) {
    if (nrow(group) > 1) {
      coords <- group[, 2:1] * resolution  # Convertir en coordonnées réelles
      tryCatch({
        st_linestring(coords)
      }, error = function(e) {
        message("Erreur lors de la création d'une ligne : ", e$message)
        return(NULL)
      })
    } else {
      NULL
    }
  })
  
  # Filtrer les lignes NULL
  lines_list <- lines_list[!sapply(lines_list, is.null)]
  
  if (length(lines_list) == 0) {
    warning("Aucune ligne n'a été créée à partir des coordonnées fournies.")
    return(NULL)
  }
  
  lines_sf <- st_sfc(lines_list, crs = crs)
  return(lines_sf)
}


[1] "Dimensions du MNT: 1235x1605x1"
[1] "Dimensions de la pente: 1235x1605x1"
[1] "Dimensions des zones planes: 1235x1605x1"
[1] "Dimensions de la matrice d'image: 1235x1605"
[1] "Dimensions des contours: 1234x1605"
[1] "Nombre de points de contour: 77024"
Erreur lors de la création des lignes : l'argument est de longueur nulle
Aucune ligne n'a été créée. Vérifiez les paramètres ou les données d'entrée.
Message d'avis :
There were 3191 degenerated ground points. Some X Y coordinates were repeated but with different Z coordinates. min Z were retained.
