---
title: Télédétection des cloisonnements d'exploitation forestière à partir de données
  LiDAR
author: "Armange Tristan, Gerval Thomas, Magnier Mathieu, Marie Gabriel"
date: "2024-09-09"
output:
  html_document:
    df_print: paged
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Introduction

Les cloisonnements sont des outils sylvicoles important pour lutter contre le tassement des sols forestiers et préserver leur productivité. En effet, en fonction de la texture su sol, le tassement peut être plus ou moins important lors du passage des engins et ainsi réduire la porosité et donc la réserve utile en eau du sol. Cependant, il n’existe pas de carte accessible de ces cloisonnements lorsqu’ils existent. Ceux-ci peuvent alors être perdus avec le temps. L’utilisation du LiDAR (Light Detection And Ranging) semble être une solution. Le LiDAR consiste en une mesure de distance par détection de la lumière *(IGN, 2021)*. Actuellement, en France un projet de LiDAR (LiDAR HD), vise à cartographier l’ensemble du territoire avec une haute densité (10 points par m²) *(IGN, 2021)*, pour le moment 2/3 du territoire a été survolé. Ainsi cela mène à la question suivante : Comment déterminer les cloisonnements grâce à des données LiDAR ?

IGN. 2021. Lidar aéroporté : des mesures de précision - Institut - IGN. https://www.ign.fr/institut/kiosque/lidar-aeroporte-des-mesures-de-precision (Consulté le 10 septembre 2024). 
IGN. 2021. LiDAR HD : vers une nouvelle cartographie 3D du territoire - Institut - IGN. https://www.ign.fr/institut/lidar-hd-vers-une-nouvelle-cartographie-3d-du-territoire (Consulté le 10 septembre 2024). 



# Matériel et Méthode
## Origine des données et zone d'étude
La base de données de l'IGN offre en libre accès les données issues de ses survols LiDAR. Ces nuages de points possèdent de nombreux paramètres : coordonnées spatiales (X, Y, Z) et temporelle, intensité et nombre de retours, etc... Les fichiers sont de types .las ou .laz. Pour tester et ajuster le modèle plusieurs forêts de nature variées ont été testées. Au final 3 forêts ont été retenus pour montrer les réussites et limites du modèle : une plantation de pin dans les landes, une forêt de feuillus en montagne et une forêt de feuillus en plaine.


```{r, echo=FALSE}
knitr::include_graphics("https://drive.google.com/uc?export=view&id=1KBIgPd05gYWKF0e0Icea6pGEWomStboI")
```

Les programmes on été fait sous R avec Rstudio. Les IA Claude et Chat GPT on été utilisés pour aider au codage des différentes fonctions. Les produits issus des codes peuvent être traités par QGIS avec par exemple des Voronoi dans le but d'améliorer les résultats. 


## Récupération des données sur R
### Packages
La plus grande partie du travail a été effectué sur Rstudio. Le traitement s'est appuyé sur de nombreuses fonctions déjà disponibles dans des packages adaptés aux données manipulées.\
Le package principal est `lidR` *David Auty* qui permet de réaliser de nombreuses opérations sur les fichiers LiDAR. Afin de passer de ces fichiers 3D à un format 2D adaptée à la cartographie on utilise la fonction `lidR::rasterize()` puis le package `terra`*Robert Hijmans* permet de réaliser des opérations sur les rasters ainsi créés.

```{r, include = FALSE}
library(sf)  # for vector
library(tmap); tmap_mode("view")  # Set map to interactive
library(dplyr)
library(ggplot2);sf_use_s2(FALSE)  # Avoid problem with spherical geometry
library(purrr)
library(stars)
library(terra)  # for raster
library(jsonlite)  # to manipulate .json
library(lidR)
``` 

### Chemin d'accès 
Une première manipulation simple permet d'automatiser les chemins d'accès de l'utilsateurs et éviter des erreurs de lecture par la suite : 
```{r, results = "hide"}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
dir <- getwd()
```

### Extraction des données
La première étape consiste à récupérer les coordonnées de la zone étudiée. L'utilisation de la fonction drawFeatures() du package mapedit permet de demander à l'utilsateur d'encadrer directement sur une carte interactive la zone souhaitée. La zone doit impérativement faire partie des zones couvertes par LiDAR HD.
```{r}
draw.area = function(){
  zone = st_coordinates(st_transform(mapedit::drawFeatures(), crs = 2154))
  y1 = min(zone[, 2])
  x1 = min(zone[, 1])
  y2 = max(zone[, 2])
  x2 = max(zone[, 1])
  return(c(x1,y1,x2,y2))
}
```

L'étape d'après consiste à télécharger les tuiles de l'IGN correspondant à la zone d'étude. Cette étape s'appuie sur l'utilisation du package jsonlite qui cherche la source de données et extrait le fichier au format .laz. *autre api marche pas ? + qu'en est-il de serveurs pas stables*

```{r}
download.lidar = function(x1, y1, x2, y2) {
  # Créer une séquence de coordonnées avec un pas de 10000
  x = seq(x1, x2, 10000)
  y = seq(y1, y2, 10000)
  
  # Boucle à travers toutes les combinaisons de x et y
  for (i in x) {
    for (j in y) {
      # Construire l'URL pour obtenir les données JSON
      json_url <- paste0("https://data.geopf.fr/private/wfs/?service=WFS&version=2.0.0&apikey=interface_catalogue&request=GetFeature&typeNames=IGNF_LIDAR-HD_TA:nuage-dalle&outputFormat=application/json&bbox=", 
                         i, ",", j, ",", i, ",", j)
      print(paste("Fetching JSON from:", json_url))
      
      # Essayer de récupérer les données JSON
      tryCatch({
        json = fromJSON(txt = json_url)
        
        # Récupérer le lien du fichier .laz à partir des propriétés du JSON
        lien = json[["features"]][["properties"]][["url"]][1]
        
        if (!is.null(lien)) {  # Vérifier que le lien n'est pas nul
          print(paste("Downloading .laz file from:", lien))
          
          # Téléchargement du fichier .laz avec mode binaire
          download.file(lien, 
                        destfile = paste0("dir", i, "_", j, ".laz"),
                        mode = "wb")  # "wb" pour mode binaire
          
          print(paste("Saved file:", paste0(i, "_", j, ".laz")))
        } else {
          print("No valid link found in the JSON response.")
        }
      }, error = function(e) {
        print(paste("Error fetching or downloading data for bbox:", i, j))
        print(e)  # Affiche l'erreur rencontrée
      })
    }
  }
}
```

Une fois les tuiles récupérées, elles ne peuvent pas être traitées en l'état du fait de leur taille (emprise de 10 kha). L'emprise est donc ramenée à la valeur spécifiée au début par l'utilisateur.
```{r}
cut.area = function(laz, liste){
  clip = clip_rectangle(laz, liste[1], liste[2], liste[3], liste[4])
  return(clip)
}
```
Après ces différentes étapes un fichier .laz est créé et servira de base pour les différents traitements.

## Détection des cloisonnements sur R

La fonction `detect.cloiso()` est la fonction principale du code. Le principe est le suivant : plusieurs données sont extraites du fichier d'origine, puis, en attribuant des seuils à ces valeurs, les points sont classés et discriminés si le nombre de critères remplis est suffisant.\
Le nombre de retours correspond au nombre de fois où le laser a croisé des éléments et a été renvoyé vers l'appareil. A priori un cloisonnement devrait avoir un faible nombre de retour puisque le couvert y est moins important que dans le reste de la parcelle.\
```{r}
detect.cloiso <- function(laz, resolution = 1, threshold = 0.1, output_file = "cloisonnements.gpkg") {
  if (is.null(laz) || npoints(laz) == 0) {
    stop("Le fichier LAZ est vide ou n'a pas été chargé correctement.")
  }
  
  # Calculer le nombre de retours
  returns <- grid_metrics(laz, ~length(Z), res = resolution / 2)
  names(returns) <- "num_returns"
  
  # MNH/mnt (Modèle Numérique de Hauteur)
  mnt1 = grid_terrain(laz, res = resolution / 2, algorithm = tin())
  laplacian_kernel <- matrix(c(1, 1, 1,
                               1, -8, 1,
                               1, 1, 1), 
                             nrow = 3, ncol = 3)
  
  # Appliquer le filtre Laplacien au raster
  mnt_sqrt <- focal(mnt1, w = laplacian_kernel, fun = sum, na.policy = "omit", pad = TRUE)
  names(mnt_sqrt) <- "mnt"
  norm = normalize_height(laz, mnt1)
  mnh <- grid_canopy(norm, res = resolution / 2, algorithm = pitfree())
  names(mnh) <- "mnh_height"
  
  
  # Empiler les rasters pour les combiner
  combined_stack <- raster::stack(returns, mnh, mnt_sqrt)
  
  # Convertir en data frame pour traitement
  combined_df <- as.data.frame(combined_stack, xy = TRUE)
  combined_df <- na.omit(combined_df)
  
  # Détecter les zones à faible densité, faible nombre de retours et faible hauteur
  combined_df$low_returns <- ifelse(combined_df$num_returns < 6, 1, 0)
  combined_df$low_mnh <- ifelse(combined_df$mnh_height < 3, 1, 0)
  combined_df$low_mnt = ifelse(combined_df$mnt < quantile(combined_df$mnt, threshold, na.rm = TRUE), 1, 0)
 
  # Détecter les cloisonnements avec une pondération
  combined_df$cloisonnement <- with(combined_df, (low_returns * 0.33 + low_mnh * 0.33 + low_mnt * 0.33) > 0.65)
  
  # Filtrer les zones de cloisonnements
  cloisonnements_points <- combined_df[combined_df$cloisonnement, ]
  
  if (nrow(cloisonnements_points) > 0) {
    # Convertir en objet spatial
    cloisonnements_sf <- st_as_sf(cloisonnements_points, coords = c("x", "y"), crs = st_crs(laz))
    
    # Appliquer un buffer et dissoudre pour connecter les points proches
    cloisonnements_buffer <- st_buffer(cloisonnements_sf, dist = resolution)
    cloisonnements_dissolved <- st_union(cloisonnements_buffer)
    
    # Simplifier les lignes pour réduire le bruit
    centerlines_simplified <- st_simplify(cloisonnements_dissolved, dTolerance = resolution / 2)
    
    # Lisser les lignes pour un résultat plus naturel
    cloisonnements_smooth <- st_simplify(centerlines_simplified, dTolerance = resolution / 4)
    
    # Exporter au format GPKG
    st_write(cloisonnements_smooth, output_file, driver = "GPKG", delete_layer = TRUE)
    message("Cloisonnements exportés vers ", output_file)
    
    return(cloisonnements_smooth)
  } else {
    message("Aucun cloisonnement détecté.")
    return(NULL)
  }
}
```


## Détection des cloisonnements sur QGIS
En plus des tentatives de détection des cloisonnements sur R, une deuxième approche sur QGis a été mise en place.
L'automatisation est alors abandonnée au profit de l'adaptabilité d'un opérateur et d'une détéction plus précise. De plus certaines fonctions comme Voronoi sont plus simple d'utilisation sur QGis.\
La fin du processus de détection nécessite l'interprétation des vecteurs créés qui est également optimisé par la visualisation sur QGIS.


# Résultats

Le code ci-après a été amputé de la partrie drawfeature pour présenter les zones d'étude.
```
coord <- draw.area()
```

```
coord <- [insérer coord]
download.lidar(coord[1],coord[2],coord[3],coord[4])


```



# Discussion

La principale contrainte relative à ces données est leur taille importante. Il est pour l'instant inenvisageable de travailler à l'échelle de massifs forestiers entiers.\
A l'heure actuelle la détection des cloisonnements a été testée sur des morceaux de forêts de différentes natures (plantations ou non, feuillus ou résineux, peuplements âgés ou jeunes,...) sans pour autant être exhaustive. Une étude supplémentaire serait nécessaire pour déterminer les facteurs nécessaires à une détection de qualité. Pour l'instant l'absence de détection n'exclue pas la présence des cloisonnements.\
En plus des cloisonnements actuels, une approche supplémentaire sur la présence d'anciens cloisonnements ou passage de véhicules serait une information importante à donner au gestionnaire.\
Il a également été remarqué que ce programme ne fonctionne pas pour détécter les cloisonnements lorsque la densité de couvert est trop élevée, un autre projet pour adapter ce programme aux différents contexte forestier pourrait donc être envisagé. On peut imaginer soit un autre programme, soit une adaptation de ce dernier avec des valeurs changeantes en fonction du contexte forestier. D'autre packages peuvent être utilisés pour des applications forestières comme [comme le package LiDARHD de l'IGN](https://www.theia-land.fr/product/lidarhd-un-package-r-pour-telecharger-et-gerer-les-fichiers-lidar-hd/) ou encore le [package sur la caractèrisation de la structure forestière](https://www.theia-land.fr/product/lidartree-un-package-r-pour-la-caracterisation-de-la-structure-des-forets-par-teledetection-lidar/).
*mentionner le travail à l'echelle du terrain ou les cloiso sont deja visibles = quel interet à l'approche aerienne si on ne peut pas visualiser des grands ensembles.*
Les cloisonnements sont détectés au même titre que des pistes forestières. Il faudrait ajouter un traitement permettant de les discriminer. De même la détection s'accompagne de nombreuses formes superflues ne correspondant pas aux cloisonnements. Ce bruit pourrait être retiré en complexifiant les fonctions.

# Conclusion

Les programmes développés lors de ces deux semaines on permis de de produire quelques resultats prometteurs sur des forêts où la densité est faible. A l'inverse, des améliorations sont à apporter concernant les boisements plus denses. 


