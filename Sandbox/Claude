detect.cloiso <- function(laz_norm, resolution = 1, threshold = 0.1, min_area = 25, output_file = "cloisonnements_norm.gpkg") {
  if (is.null(laz_norm) || npoints(laz_norm) == 0) {
    stop("Le fichier LAZ est vide ou n'a pas été chargé correctement.")
  }
  
  # 1-4. Calculs préliminaires (inchangés)
  density <- grid_density(laz_norm, res = resolution)
  returns <- grid_metrics(laz_norm, ~length(Z), res = resolution)
  names(returns) <- "num_returns"
  mnh <- grid_canopy(laz_norm, res = resolution, algorithm = pitfree())
  names(mnh) <- "mnh_height"
  
  combined_stack <- raster::stack(density, returns, mnh)
  combined_df <- as.data.frame(combined_stack, xy = TRUE)
  combined_df <- na.omit(combined_df)
  
  # 5-6. Détection des zones de cloisonnement (inchangé)
  combined_df$low_density <- ifelse(combined_df$density < quantile(combined_df$density, threshold, na.rm = TRUE), 1, 0)
  combined_df$low_returns <- ifelse(combined_df$num_returns < quantile(combined_df$num_returns, threshold, na.rm = TRUE), 1, 0)
  combined_df$low_mnh <- ifelse(combined_df$mnh_height < quantile(combined_df$mnh_height, threshold, na.rm = TRUE), 1, 0)
  combined_df$cloisonnement <- ifelse(combined_df$low_density == 1 & combined_df$low_returns == 1 & combined_df$low_mnh == 1, 1, 0)
  
  # 7-8. Création des polygones avec attributs
  cloisonnements_points <- combined_df[combined_df$cloisonnement == 1, ]
  if (nrow(cloisonnements_points) > 0) {
    cloisonnements_sf <- st_as_sf(cloisonnements_points, coords = c("x", "y"), crs = st_crs(laz_norm))
    
    # 9. Créer des polygones à partir des points
    cloisonnements_buffer <- st_buffer(cloisonnements_sf, dist = resolution / 2)
    cloisonnements_polygons <- st_union(cloisonnements_buffer)
    cloisonnements_polygons <- st_cast(cloisonnements_polygons, "POLYGON")
    
    # 10. Simplifier les polygones
    cloisonnements_simplified <- st_simplify(cloisonnements_polygons, dTolerance = resolution)
    
    # 11. Filtrer les polygones trop petits et ajouter des attributs
    min_area_units <- units::set_units(min_area, "m^2")
    cloisonnements_filtered <- cloisonnements_simplified[st_area(cloisonnements_simplified) > min_area_units]
    
    # Créer un data frame avec les attributs
    attributes_df <- data.frame(
      id = 1:length(cloisonnements_filtered),
      area = as.numeric(st_area(cloisonnements_filtered)),
      perimeter = as.numeric(st_length(st_cast(cloisonnements_filtered, "MULTILINESTRING")))
    )
    
    # Combiner les géométries avec les attributs
    cloisonnements_with_attributes <- st_sf(attributes_df, geometry = cloisonnements_filtered)
    
    # 12. Exporter au format GPKG
    st_write(cloisonnements_with_attributes, output_file, driver = "GPKG", delete_layer = TRUE)
    message("Cloisonnements exportés vers ", output_file)
    
    return(cloisonnements_with_attributes)
  } else {
    message("Aucun cloisonnement détecté.")
    return(NULL)
  }
}



Erreur dans data.frame(id = 1:length(cloisonnements_filtered), area = as.numeric(st_area(cloisonnements_filtered)),  : 
  les arguments impliquent des nombres de lignes différents : 2, 0
