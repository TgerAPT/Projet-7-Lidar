detect.cloiso <- function(laz_norm, resolution = 0.5, line_length = 20, gap_fill = 5, slope_threshold = 5, output_file = "cloisonnements_norm.gpkg") {
  
  if (is.null(laz_norm) || npoints(laz_norm) == 0) {
    stop("Le fichier LAZ est vide ou n'a pas été chargé correctement.")
  }
  
  # Nettoyage des points dégénérés
  laz_norm <- filter_duplicates(laz_norm)
  
  # 1. Créer un MNT à haute résolution
  mnt <- grid_terrain(laz_norm, res = resolution, algorithm = tin())
  
  # 2. Calculer la pente
  slope <- terrain(mnt, opt = "slope", unit = "degrees")
  
  # 3. Identifier les zones planes (potentiels cloisonnements)
  flat_areas <- slope < slope_threshold
  
  # 4. Convertir en image pour le traitement
  img <- as.cimg(as.matrix(flat_areas))
  
  # 5. Appliquer un filtre morphologique pour nettoyer l'image
  kernel <- imager::as.cimg(matrix(1, nrow = 5, ncol = 5))
  img_clean <- imager::dilate(imager::erode(img, kernel), kernel)
  
  # 6. Détection de contours simple
  dx <- diff(img_clean[,1:(dim(img_clean)[2]-1),1,1])
  dy <- diff(img_clean[1:(dim(img_clean)[1]-1),,1,1])
  edges <- sqrt(dx^2 + dy^2)
  
  # 7. Binarisation des contours
  edges_bin <- edges > quantile(edges, 0.9, na.rm = TRUE)
  
  # 8. Extraction des coordonnées des pixels de contour
  edge_coords <- which(edges_bin > 0, arr.ind = TRUE)
  
  # 9. Création des lignes à partir des coordonnées des contours
  lines_sf <- st_sfc(lapply(1:(nrow(edge_coords)-1), function(i) {
    st_linestring(matrix(c(edge_coords[i,2], edge_coords[i,1],
                           edge_coords[i+1,2], edge_coords[i+1,1]), ncol = 2, byrow = TRUE))
  }), crs = st_crs(laz_norm))
  
  # 10. Filtrer les lignes trop courtes
  lines_sf <- lines_sf[st_length(lines_sf) > line_length]
  
  # 11. Fusionner les lignes proches
  lines_buffered <- st_buffer(lines_sf, dist = gap_fill)
  lines_merged <- st_cast(st_union(lines_buffered), "LINESTRING")
  
  # 12. Nettoyer et simplifier les lignes finales
  lines_final <- st_simplify(lines_merged, dTolerance = resolution)
  
  # 13. Exporter au format GPKG
  st_write(lines_final, output_file, driver = "GPKG", delete_layer = TRUE)
  message("Cloisonnements exportés vers ", output_file)
  
  return(lines_final)
}
